#!/usr/bin/env python

# This node subscribes to darknet_ros/bounding_boxes (array of bounding boxes), 
# and /scan (lidar data). The node publishes to the topic /object_map.

from __future__ import division
import sys, math
import rospy
import darknet_ros_msgs.msg as darknet
from sensor_msgs.msg import LaserScan

# Default camera specs (Raspberry Pi Camera Module v2)
FIELD_OF_VIEW=62.2 # horizontal degrees
RESOLUTION_WIDTH=1280
DISTANCE_BT_LIDAR_CAM = 0.14 # Distance between lidar and camera, in meters

class object_map:

    def __init__(self, fov=FIELD_OF_VIEW, total_columns=RESOLUTION_WIDTH):
        '''Initialize ROS subscriber, camera specs'''
        self.bounding_boxes = rospy.Subscriber("/darknet_ros/bounding_boxes", darknet.BoundingBoxes, self.b_boxes_callback)
        self.lidar_data = rospy.Subscriber("/scan", LaserScan, self.lidar_callback)
        rospy.loginfo("Subscribing to bounding boxes topic /darknet_ros/bounding_boxes")
        self.total_columns = total_columns
        self.fov = fov
        self.degrees_per_column = fov/self.total_columns # horizontal degrees
        self.boxes = []
        self.obstacle_locs = []
    
    def x_pos_to_angle(self, x_coor):
        '''Converts a pixel's x position to an angle, where zero degrees 
           is directly in front of the camera and positive is counter-clockwise'''
        x_origin = self.total_columns/2
        return (x_origin - x_coor)*self.degrees_per_column
        
    def b_boxes_callback(self, data):
        self.boxes = []
        for bounding_box in data.bounding_boxes:
            box = {
                "class": bounding_box.Class,
                "id": bounding_box.id,
                "probability": bounding_box.probability,
                "min_angle": math.floor(self.x_pos_to_angle(bounding_box.xmax)), # swap xmax and xmin because coordinate system is reversed
                "max_angle": math.ceil(self.x_pos_to_angle(bounding_box.xmin))
            }
            self.boxes.append(box)
        # rospy.loginfo(str(self.boxes))

    def change_ref_frame(self, radius, angle):
        '''Changes lidar data to a coordinate system where the origin 
        is at the camera instead of the lidar sensor. 0 degrees is in front,
        positive is counter-clockwise.'''
        if radius <= 0.01:
            return angle, 0
        if angle == 0:
            return 0, radius - DISTANCE_BT_LIDAR_CAM
        theta = angle/180 * math.pi
        x_length = radius * math.sin(theta)
        y_length = radius * math.cos(theta) - DISTANCE_BT_LIDAR_CAM
        new_radius = math.sqrt(math.pow(x_length,2) + math.pow(y_length,2))
        new_angle = math.asin(x_length/new_radius)/math.pi*180
        return new_radius, new_angle

    def lidar_callback(self, data):
        lidar_data = data.ranges
        range_min = data.range_min
        range_max = data.range_max
        data_to_convert = lidar_data[:int(math.ceil(self.fov/2))] + lidar_data[int(math.ceil(self.fov/2)*-1):]
        converted_data = []
        for i in range(int(math.ceil(self.fov/2))):
            converted_data.append(self.change_ref_frame(data_to_convert[i], i))
        for i in range(-1*int(math.ceil(self.fov/2)), 0):
            converted_data.append(self.change_ref_frame(data_to_convert[i], i))
        self.obstacle_locs = []
        if len(self.boxes) > 0:
            for box in self.boxes: 
                obstacle = box
                polar_coords = []
                for radius, angle in converted_data:
                    if angle >= obstacle["min_angle"] and angle <= obstacle["max_angle"] \
                        and radius >= self.change_ref_frame(range_min, angle)[0] \
                            and radius <= self.change_ref_frame(range_max, angle)[0]:
                        polar_coords.append((radius, angle))
                obstacle["polar_coords"] = polar_coords
                self.obstacle_locs.append(obstacle)
        rospy.loginfo(self.obstacle_locs)


        
def main(args):
    '''Initializes and cleanup ROS node'''
    slam = object_map()
    rospy.init_node('object_map', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        rospy.loginfo("Shutting down object mapping")

if __name__ == '__main__':
    main(sys.argv)
