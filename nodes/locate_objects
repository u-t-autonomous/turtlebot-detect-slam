#!/usr/bin/env python

# This node subscribes to darknet_ros/bounding_boxes (array of bounding boxes), 
# and /scan (lidar data). The node publishes to the topic /object_map.

from __future__ import division
import sys, math
import rospy
import cv2
import darknet_ros_msgs.msg as darknet
from sensor_msgs.msg import LaserScan, Image
from cv_bridge import CvBridge, CvBridgeError
import random

# Default camera specs (Raspberry Pi Camera Module v2)
FIELD_OF_VIEW=62.2 # horizontal degrees
RESOLUTION_WIDTH=1280
DISTANCE_BT_LIDAR_CAM = 0.14 # Distance between lidar and camera, in meters

class object_map:

    def __init__(self, fov=FIELD_OF_VIEW, total_columns=RESOLUTION_WIDTH):
        '''Initialize ROS subscriber, camera specs'''
        self.bounding_boxes = rospy.Subscriber("/darknet_ros/bounding_boxes", darknet.BoundingBoxes, self.b_boxes_callback)
        self.lidar_data = rospy.Subscriber("/scan", LaserScan, self.lidar_callback)
        rospy.loginfo("Subscribing to bounding boxes topic /darknet_ros/bounding_boxes")
        self.total_columns = total_columns
        self.fov = fov
        self.degrees_per_column = fov/self.total_columns # horizontal degrees
        self.boxes = []
        self.obstacle_locs = []
        self.converted_data = []
        '''visualizer'''
        self.image_sub = rospy.Subscriber("/darknet_ros/detection_image", Image, self.image_callback)
        self.bridge = CvBridge()
        self.visualizer = rospy.Publisher("/lidar_yolo_visualizer", Image)
    
    def image_callback(self, data):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            print(e)
        i = 0
        y = 340
        for obstacle in self.obstacle_locs:
            if len(obstacle["polar_coords"]) == 0:
                continue
            if i % 3 == 0:
                color = (255, 0, 255)
            elif i % 3 == 1:
                color = (0, 255, 0)
            else:
                color = (0, 0, 255)
            i = i+1
            for point in obstacle["polar_coords"]:
                x = self.angle_to_x_pos(point[1])
                cv_image[y:y+20, x:x+10] = color

        # if len(self.converted_data) > 0:
        #     y = y-10
        #     for point in self.converted_data:
        #         x = self.angle_to_x_pos(point[1])
        #         cv_image[y:y+20, x:x+10] = (255,255,255)
        try:
            self.visualizer.publish(self.bridge.cv2_to_imgmsg(cv_image, "bgr8"))
        except CvBridgeError as e:
            print(e)


    def x_pos_to_angle(self, x_coor):
        '''Converts a pixel's x position to an angle, where zero degrees 
           is directly in front of the camera and positive is counter-clockwise'''
        x_origin = self.total_columns/2
        return (x_origin - x_coor)*self.degrees_per_column

    def angle_to_x_pos(self, angle):
        x_origin = self.total_columns/2
        return int(round(angle/self.degrees_per_column*-1 + x_origin))    
        
    def b_boxes_callback(self, data):
        self.boxes = []
        for bounding_box in data.bounding_boxes:
            box = {
                "class": bounding_box.Class,
                "id": bounding_box.id,
                "probability": bounding_box.probability,
                "min_angle": math.floor(self.x_pos_to_angle(bounding_box.xmax)), # swap xmax and xmin because coordinate system is reversed
                "max_angle": math.ceil(self.x_pos_to_angle(bounding_box.xmin))
            }
            self.boxes.append(box)
        # rospy.loginfo(str(self.boxes))

    def change_ref_frame(self, radius, angle):
        '''Changes lidar data to a coordinate system where the origin 
        is at the camera instead of the lidar sensor. 0 degrees is in front,
        positive is counter-clockwise.'''
        if radius <= 0.01:
            return 0, angle
        if angle == 0:
            return max(radius - DISTANCE_BT_LIDAR_CAM, DISTANCE_BT_LIDAR_CAM), 0
        theta = angle/180 * math.pi
        x_length = radius * math.sin(theta)
        y_length = radius * math.cos(theta) - DISTANCE_BT_LIDAR_CAM
        new_radius = math.sqrt(math.pow(x_length,2) + math.pow(y_length,2))
        new_angle = math.asin(x_length/new_radius)/math.pi*180
        return new_radius, new_angle

    def lidar_callback(self, data):
        lidar_data = data.ranges
        range_min = data.range_min
        range_max = data.range_max
        data_to_convert = lidar_data[:int(math.ceil(self.fov/2))] + lidar_data[int(math.ceil(self.fov/2)*-1):]
        self.converted_data = []
        for i in range(int(math.ceil(self.fov/2))):
            self.converted_data.append(self.change_ref_frame(data_to_convert[i], i))
        for i in range(-1*int(math.ceil(self.fov/2)), 0):
            self.converted_data.append(self.change_ref_frame(data_to_convert[i], i))
        self.obstacle_locs = []
        if len(self.boxes) > 0:
            for box in self.boxes: 
                obstacle = box
                polar_coords = []
                for radius, angle in self.converted_data:
                    if angle >= obstacle["min_angle"] and angle <= obstacle["max_angle"] \
                        and radius >= self.change_ref_frame(range_min, angle)[0] \
                            and radius <= self.change_ref_frame(range_max, angle)[0]:
                        polar_coords.append((radius, angle))
                obstacle["polar_coords"] = polar_coords
                self.obstacle_locs.append(obstacle)
        rospy.loginfo(self.obstacle_locs)


        
def main(args):
    '''Initializes and cleanup ROS node'''
    slam = object_map()
    rospy.init_node('object_map', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        rospy.loginfo("Shutting down object mapping")

if __name__ == '__main__':
    main(sys.argv)
